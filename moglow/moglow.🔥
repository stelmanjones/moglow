var CSI = "\x1b["

from collections.dict import Dict, KeyElement
from moglow.collections import StringKey
from testing import assert_true, assert_false, assert_equal, assert_not_equal


fn convert_base16_to_base10(value: String) raises -> Int:
    """Converts a base 16 number to base 10.
    https://www.catalyst2.com/knowledgebase/dictionary/hexadecimal-base-16-numbers/#:~:text=To%20convert%20the%20hex%20number,16%20%2B%200%20%3D%2016).
    """
    var mapping = Dict[StringKey, Int]()
    mapping["0"] = 0
    mapping["1"] = 1
    mapping["2"] = 2
    mapping["3"] = 3
    mapping["4"] = 4
    mapping["5"] = 5
    mapping["6"] = 6
    mapping["7"] = 7
    mapping["8"] = 8
    mapping["9"] = 9
    mapping["a"] = 10
    mapping["b"] = 11
    mapping["c"] = 12
    mapping["d"] = 13
    mapping["e"] = 14
    mapping["f"] = 15

    let length = len(value)
    var sum: Int = 0
    for i in range(length - 1, -1, -1):
        let exponent = length - 1 - i
        sum += mapping[value[i]] * (16**exponent)

    return sum


let LITERALS = [
    ("bold", FontStyle.Bold),
    ("dim", FontStyle.Dim),
    ("italic", FontStyle.Italic),
    ("underline", FontStyle.Underline),
    ("blinking", FontStyle.Blinking),
    ("inverse", FontStyle.Inverse),
    ("hidden", FontStyle.Hidden),
    ("strikethrough", FontStyle.Strikethrough),
    ("black", Color.Black),
    ("red", Color.Red),
    ("green", Color.Green),
    ("yellow", Color.Yellow),
    ("blue", Color.Blue),
    ("magenta", Color.Magenta),
    ("cyan", Color.Cyan),
    ("white", Color.White),
    ("default", Color.Default),
    ("bright_black", Color.BrightBlack),
    ("bright_red", Color.BrightRed),
    ("bright_green", Color.BrightGreen),
    ("bright_yellow", Color.BrightYellow),
    ("bright_blue", Color.BrightBlue),
    ("bright_magenta", Color.BrightMagenta),
    ("bright_cyan", Color.BrightCyan),
    ("bright_white", Color.BrightWhite),
]


@value
struct ColorType(Stringable):
    var value: Int

    alias Foreground = ColorType(3)
    alias Background = ColorType(4)
    alias BrightForeground = ColorType(9)
    alias BrightBackground = ColorType(10)

    fn __str__(self) -> String:
        return self.value


@value
struct ColorRGB(Stringable):
    var r: UInt8
    var g: UInt8
    var b: UInt8

    fn __init__(inout self, r: UInt8, g: UInt8, b: UInt8):
        self.r = r
        self.g = g
        self.b = b

    fn __str__(self) -> String:
        return "38;2;{" + str(self.r) + "};{" + self.g + "};{" + self.b + "}"

    fn as_fg(self) -> String:
        return "38;2;" + str(self.r) + ";" + self.g + ";" + self.b

    fn as_bg(self) -> String:
        return "48;2;" + str(self.r) + ";" + self.g + ";" + self.b

    @staticmethod
    fn from_hex(self, value: String) raises -> ColorRGB:
        """Converts a hex color to RGB.

        Args:
            value: Hex color value.

        Returns:
            RGB color.
        """

        let hex = value[1:]
        var indices: DynamicVector[Int] = DynamicVector[Int]()
        indices.append(0)
        indices.append(2)
        indices.append(4)

        var results: DynamicVector[Int] = DynamicVector[Int]()
        for i in range(len(indices)):
            let base_10 = convert_base16_to_base10(hex[indices[i] : indices[i] + 2])
            results.append(atol(base_10))

        return ColorRGB(results[0], results[1], results[2])


trait ANSIable:
    fn sequence(self, escaped: Bool) -> String:
        pass


@value
struct FontStyle(Stringable, Intable):
    var value: Int

    alias Bold = FontStyle(1)
    alias Dim = FontStyle(2)
    alias Italic = FontStyle(3)
    alias Underline = FontStyle(4)
    alias Blinking = FontStyle(5)
    alias Inverse = FontStyle(7)
    alias Hidden = FontStyle(8)
    alias Strikethrough = FontStyle(9)

    fn __str__(self) -> String:
        return self.value

    fn __int__(self) -> Int:
        return self.value

    fn __eq__(self, other: FontStyle) -> Bool:
        return self.value == other.value


@value
struct Color(Stringable, Intable):
    var value: Int
    var bright: Bool

    alias Black = Color(0)
    alias Red = Color(1)
    alias Green = Color(2)
    alias Yellow = Color(3)
    alias Blue = Color(4)
    alias Magenta = Color(5)
    alias Cyan = Color(6)
    alias White = Color(7)
    alias Default = Color(9)
    alias BrightBlack = Color(0, True)
    alias BrightRed = Color(1, True)
    alias BrightGreen = Color(2, True)
    alias BrightYellow = Color(3, True)
    alias BrightBlue = Color(4, True)
    alias BrightMagenta = Color(5, True)
    alias BrightCyan = Color(6, True)
    alias BrightWhite = Color(7, True)

    fn __init__(inout self, value: Int, bright: Bool = False):
        self.value = value
        self.bright = bright

    fn __gt__(self, other: Color) -> Bool:
        return self.value > other.value

    fn __lt__(self, other: Color) -> Bool:
        return self.value < other.value

    fn __str__(self) -> String:
        return self.value

    fn __int__(self) -> Int:
        return self.value

    fn __eq__(self, other: Color) -> Bool:
        return self.value == other.value

    fn as_fg(self) -> String:
        let prefix: String
        if self.bright:
            prefix = "9"
        else:
            prefix = "3"
        return prefix + str(self.value)

    fn as_bg(self) -> String:
        let prefix: String
        if self.bright:
            prefix = "10"
        else:
            prefix = "4"
        return prefix + str(self.value)


struct Style(ANSIable, Stringable):
    var fg: Color
    var bg: Color
    var style: FontStyle

    fn __init__(
        inout self,
        fg: Color = Color.Default,
        bg: Color = Color.Default,
        style: FontStyle = FontStyle(0),
    ):
        self.fg = fg
        self.bg = bg
        self.style = style

    fn sequence(self, escaped: Bool = False) -> String:
        let csi: String

        if escaped:
            csi = "\\x1b["
        else:
            csi = "\x1b["
        return (
            csi
            + str(self.style)
            + ";"
            + self.fg.as_fg()
            + ";"
            + "4"
            + self.bg.as_bg()
            + "m"
        )

    fn __str__(self) -> String:
        let csi = "\x1b["
        return (
            csi + str(self.style) + ";" + str(self.fg) + ";" + "4" + str(self.bg) + "m"
        )

    fn set_fg(inout self, color: Color, bright: Bool = False):
        """
        Set the foreground color to the given value.
        """
        self.fg = color

    fn set_bg(inout self, color: Color, bright: Bool = False):
        """
        Set the background color to the given value.
        """
        self.bg = color

    fn set_style(inout self, style: FontStyle):
        """
        Set the font style to the given value.
        """
        self.style = style

    fn set_fg(inout self, index: Int):
        """
        Set the foreground color to the given value.
        """

        try:
            assert_true(index >= 0 and index <= 255, "")
        except:
            print("Color index must be between 0 and 255")
            return
        self.fg = Color(index)

    fn set_bg(inout self, index: Int):
        """
        Set the background color to the given value.
        """
        try:
            assert_true(index >= 0 and index <= 255, "")
        except:
            print("Color index must be between 0 and 255")
            return
        self.fg = Color(index)
        self.bg = Color(index)

    fn print(self, s: String, newline: Bool = True):
        if not newline:
            print_no_newline(self.sequence() + s + self.reset())
        else:
            print(self.sequence() + s + self.reset())

    fn print[s: String, newline: Bool = True](self):
        if not newline:
            print_no_newline(self.sequence() + s + self.reset())
        else:
            print(self.sequence() + s + self.reset())

    fn print[s: StringLiteral, newline: Bool = True](self):
        if not newline:
            print_no_newline(self.sequence() + s + self.reset())
        else:
            print(self.sequence() + s + self.reset())

    fn print(self, s: StringLiteral, newline: Bool = True):
        if not newline:
            print_no_newline(self.sequence() + s + self.reset())
        else:
            print(self.sequence() + s + self.reset())

    fn print(self, s: StringRef, newline: Bool = True):
        if not newline:
            print_no_newline(self.sequence() + s + self.reset())
        else:
            print(self.sequence() + s + self.reset())

    # Comptime
    fn string_render[s: String](self) -> String:
        return self.sequence() + s + self.reset()

    fn string_render[s: StringLiteral](self) -> String:
        return self.sequence() + s + self.reset()

    # Runtime
    fn string_render(self, s: String) -> String:
        return self.sequence() + s + self.reset()

    fn string_render(self, s: StringLiteral) -> String:
        return self.sequence() + s + self.reset()

    fn string_render(self, s: StringRef) -> String:
        return self.sequence() + s + self.reset()

    fn reset(self) -> String:
        return "\x1b[0m"


struct RGBStyle(ANSIable, Stringable):
    var fg: ColorRGB
    var bg: ColorRGB
    var style: FontStyle

    fn __init__(
        inout self,
        fg: ColorRGB = ColorRGB(255, 255, 255),
        bg: ColorRGB = ColorRGB(0, 0, 0),
        style: FontStyle = FontStyle(0),
    ):
        self.fg = fg
        self.bg = bg
        self.style = style

    fn sequence(self, escaped: Bool = False) -> String:
        """
        Return the ANSI escape sequence for this style.
        If `escaped` is `True`, the sequence will be escaped for use in a string literal.
        """
        let csi: String

        if escaped:
            csi = "\\x1b["
        else:
            csi = "\x1b["
        return (
            csi + str(self.style) + ";" + self.fg.as_fg() + ";" + self.bg.as_bg() + "m"
        )

    fn __str__(self) -> String:
        let csi = "\x1b["
        return (
            csi + str(self.style) + ";" + str(self.fg) + ";" + "4" + str(self.bg) + "m"
        )

    fn set_fg(inout self, r: Int, g: Int, b: Int):
        """
        Set the foreground color to the given RGB value.
        """
        try:
            assert_true(r >= 0 and r <= 255, "")
            assert_true(g >= 0 and g <= 255, "")
            assert_true(b >= 0 and b <= 255, "")
        except:
            print("Color index must be between 0 and 255")
            return
        self.fg = ColorRGB(r, g, b)

    fn set_bg(inout self, r: UInt8, g: UInt8, b: UInt8):
        """
        Set the background color to the given RGB value.
        """
        self.bg = ColorRGB(r, g, b)

    fn set_style(inout self, style: FontStyle):
        """
        Set the font style to the given value.
        """
        self.style = style

    fn set_fg(inout self, color: ColorRGB):
        """
        Set the foreground color to the given RGB value.
        """
        self.fg = color

    fn set_bg(inout self, color: ColorRGB):
        """
        Set the background color to the given RGB value.
        """
        self.bg = color

    fn print(self, s: String):
        print(self.sequence() + s + self.reset())

    fn print(self, s: StringLiteral):
        print(self.sequence() + s + self.reset())

    fn print(self, s: StringRef):
        print(self.sequence() + s + self.reset())

    fn string_render(self, s: String) -> String:
        return self.sequence() + s + self.reset()

    fn string_render(self, s: StringLiteral) -> String:
        return self.sequence() + s + self.reset()

    fn string_render(self, s: StringRef) -> String:
        return self.sequence() + s + self.reset()

    fn reset(self) -> String:
        return "\x1b[0m"
